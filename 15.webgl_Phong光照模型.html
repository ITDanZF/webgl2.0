<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script type="module">
      import { WebGL } from "./js/index.js";
      import Object3D from "./js/Object3D.js";
      import Camera from "./js/Camera.js";

      const webgl = new WebGL("canvas");

      /**
       * Phong光照模型并不是模拟真实物理世界中的光照现象，而是用3个最容易算，又刚好符合人类肉眼的三种直观印象的项，把任意复杂的光场简化成一下三个方面：平均亮度，大面明暗，局部高光
       * 1.平均亮度：环境光
       * 2.大面明暗：漫反射
       * 3.局部高光：镜面反射
       *
       *
       * 光照模型可以称为反射光模型，而Phong光照模型有三种反射光组成：
       * 1.漫反射光
       * 2.环境光
       * 3.镜面反射光
       *
       *
       * 一：漫反射：
       *    漫反射本质上是粗糙表面对入射光的均匀散射现象，其物理基础为Lambert余弦定律：表面某点反射的光强与入射光方向和法线夹角的余弦成正比，即 I∝cosθ。
       *    由于光被各向同性地散射到所有方向，反射亮度不随观察者的视角变化，因此Phong模型中的漫反射项被简化为一种理想漫反射——其光强仅取决于光源方向与表面法线的夹角，
       *    而与观察者位置无关。
       *
       *    在计算机图形学中，漫反射模型公式(这里没有背面光照问题)：
       *    <漫反射光颜色> = <入射光颜色> * cos(θ) * <物体本身的颜色>
       *    Id = kd * Il * max(0, cosθ)
       *
       *    Id：漫反射光强度
       *    kd：漫反射系数 (材质颜色值)
       *    Il：光源强度  (光源颜色 × 光源强度)
       *    cosθ：入射光方向和表面法线的夹角
       *
       * 二：环境光：
       *    除了光源发出的光之外，物体也会受周围环境反射光线的影响，而且存在多重反射光线，Phong模型采用简单的常数来近似模拟环境光。
       *    环境光模型公式：
       *    Iambient = ka * Ia
       *    Ia：表面最终得到的环境光颜色(RGB向量)
       *    ka：环境光系数 (材质颜色值)
       *
       * 三：镜面反射光：
       *     较光滑的物体表面还能看到高光，为了模拟这种效果还需要引入镜面反射，镜面反射的反射角和入射角相同
       *     镜面反射光计算公式如下:
       *     Ispecular = ks * Il * max(0, cosα) ^ n
       *     Ispecular：镜面反射光强度
       *     ks：镜面反射系数 (材质颜色值)
       *     Il：光源强度  (光源颜色 × 光源强度)
       *     cosα：入射光方向和表面法线的夹角
       *     n：光泽度因子 (决定高光区域的集中程度)
       *
       *
       * */

      // 注册着色器程序
      const vertexShaderSource = `#version 300 es
        layout(location = 0) in vec3 a_position;
        layout(location = 1) in vec3 a_normal;

        uniform mat4 u_modelMatrix;
        uniform mat4 u_viewMatrix;
        uniform mat4 u_projectionMatrix;
        uniform mat4 u_normalMatrix;

        out vec3 v_worldPosition;
        out vec3 v_normal;

        void main() {
          // 计算世界坐标系中的位置
          vec4 worldPosition = u_modelMatrix * vec4(a_position, 1.0);
          v_worldPosition = worldPosition.xyz;

          // 计算世界坐标系中的法线
          v_normal = normalize((u_normalMatrix * vec4(a_normal, 0.0)).xyz);

          // 计算最终的顶点位置
          gl_Position = u_projectionMatrix * u_viewMatrix * worldPosition;
        }
      `;

      const fragmentShaderSource = `#version 300 es
        precision mediump float;

        in vec3 v_worldPosition;
        in vec3 v_normal;

        uniform vec3 u_lightPosition;
        uniform vec3 u_cameraPosition;
        uniform vec3 u_lightColor;
        uniform vec3 u_ambientColor;
        uniform vec3 u_materialColor;
        uniform float u_shininess;

        out vec4 fragColor;

        void main() {
          // 标准化法线
          vec3 normal = normalize(v_normal);

          // 计算光线方向（从表面到光源）
          vec3 lightDirection = normalize(u_lightPosition - v_worldPosition);

          // 计算视线方向（从表面到相机）
          vec3 viewDirection = normalize(u_cameraPosition - v_worldPosition);

          // 计算反射方向 (镜面反射光方向)
          vec3 reflectDirection = reflect(-lightDirection, normal);

          // 1. 环境光计算
          vec3 ambient = u_ambientColor * u_materialColor;

          // 2. 漫反射光计算
          float diffuseFactor = max(dot(normal, lightDirection), 0.0);
          vec3 diffuse = u_lightColor * u_materialColor * diffuseFactor;

          // 3. 镜面反射光计算
          float specularFactor = pow(max(dot(viewDirection, reflectDirection), 0.0), u_shininess);
          vec3 specular = u_lightColor * vec3(1.0) * specularFactor;

          // 最终颜色 = 环境光 + 漫反射光 + 镜面反射光
          vec3 finalColor = ambient + diffuse + specular;

          fragColor = vec4(finalColor, 1.0);
        }
      `;

      const program = webgl.useProgram(vertexShaderSource, fragmentShaderSource);

      // 定义立方体顶点数据（包含位置和法线）
      const vertices = new Float32Array([
        // 前面
        -1.0, -1.0,  1.0,  0.0,  0.0,  1.0,
         1.0, -1.0,  1.0,  0.0,  0.0,  1.0,
         1.0,  1.0,  1.0,  0.0,  0.0,  1.0,
        -1.0,  1.0,  1.0,  0.0,  0.0,  1.0,

        // 后面
        -1.0, -1.0, -1.0,  0.0,  0.0, -1.0,
        -1.0,  1.0, -1.0,  0.0,  0.0, -1.0,
         1.0,  1.0, -1.0,  0.0,  0.0, -1.0,
         1.0, -1.0, -1.0,  0.0,  0.0, -1.0,

        // 上面
        -1.0,  1.0, -1.0,  0.0,  1.0,  0.0,
        -1.0,  1.0,  1.0,  0.0,  1.0,  0.0,
         1.0,  1.0,  1.0,  0.0,  1.0,  0.0,
         1.0,  1.0, -1.0,  0.0,  1.0,  0.0,

        // 下面
        -1.0, -1.0, -1.0,  0.0, -1.0,  0.0,
         1.0, -1.0, -1.0,  0.0, -1.0,  0.0,
         1.0, -1.0,  1.0,  0.0, -1.0,  0.0,
        -1.0, -1.0,  1.0,  0.0, -1.0,  0.0,

        // 右面
         1.0, -1.0, -1.0,  1.0,  0.0,  0.0,
         1.0,  1.0, -1.0,  1.0,  0.0,  0.0,
         1.0,  1.0,  1.0,  1.0,  0.0,  0.0,
         1.0, -1.0,  1.0,  1.0,  0.0,  0.0,

        // 左面
        -1.0, -1.0, -1.0, -1.0,  0.0,  0.0,
        -1.0, -1.0,  1.0, -1.0,  0.0,  0.0,
        -1.0,  1.0,  1.0, -1.0,  0.0,  0.0,
        -1.0,  1.0, -1.0, -1.0,  0.0,  0.0
      ]);

      // 定义索引数据
      const indices = new Uint16Array([
        0,  1,  2,    0,  2,  3,    // 前面
        4,  5,  6,    4,  6,  7,    // 后面
        8,  9,  10,   8,  10, 11,   // 上面
        12, 13, 14,   12, 14, 15,   // 下面
        16, 17, 18,   16, 18, 19,   // 右面
        20, 21, 22,   20, 22, 23    // 左面
      ]);

      // 注册数据
      webgl.VertexBufferData(webgl.gl.ARRAY_BUFFER, vertices, webgl.gl.STATIC_DRAW, [
        { location: 0, size: 3 }, // 位置
        { location: 1, size: 3 }  // 法线
      ]);

      webgl.IndexBufferData(webgl.gl.ELEMENT_ARRAY_BUFFER, indices, webgl.gl.STATIC_DRAW);

      // 使用Object3D创建立方体对象
      const cube = new Object3D();
      cube.setRotation(0, 40, 0); // 设置旋转角度（度）

      // 使用Camera创建相机
      const camera = new Camera(webgl.canvas.width, webgl.canvas.height);
      camera.EyePosition = [0, 0, 6]; // 设置相机位置
      camera.TargetObject = [0, 0, 0]; // 明确设置目标点

      // 手动更新视图矩阵
      camera._updateViewMatrix();

      // 设置uniform变量
      const gl = webgl.gl;

      // 获取矩阵
      const modelMatrix = cube.getModelMatrix();
      const viewMatrix = camera.ViewMatrix;
      const projectionMatrix = camera.ProjectionMatrix;
      const normalMatrix = modelMatrix; // 简化处理，使用模型矩阵作为法线矩阵

      // 使用封装的方法设置矩阵uniform
      webgl.setUniformMatrix4(program, 'u_modelMatrix', modelMatrix);
      webgl.setUniformMatrix4(program, 'u_viewMatrix', viewMatrix);
      webgl.setUniformMatrix4(program, 'u_projectionMatrix', projectionMatrix);
      webgl.setUniformMatrix4(program, 'u_normalMatrix', normalMatrix);

      // 使用封装的方法设置光照参数
      webgl.setUniform3f(program, 'u_lightPosition', 3.0, 3.0, 3.0);
      webgl.setUniform3f(program, 'u_cameraPosition', ...camera.EyePosition);
      webgl.setUniform3f(program, 'u_lightColor', 1.0, 1.0, 1.0);
      webgl.setUniform3f(program, 'u_ambientColor', 0.2, 0.2, 0.2);
      webgl.setUniform3f(program, 'u_materialColor', 0.8, 0.3, 0.3);

      // 使用封装的方法设置光泽度uniform
      webgl.setUniform1f(program, 'u_shininess', 32.0);

      // 启用深度测试
      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);

      // 设置清除颜色
      gl.clearColor(0.1, 0.1, 0.1, 1.0);

      // 绘制
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
    </script>
  </body>
</html>
