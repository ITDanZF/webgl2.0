1.请介绍一下webgl？
webgl 基于Opengl ES 2.0封装的javaScript图形库,在浏览器中可以使用js控制GPU进行3D图形的渲染

2.请介绍webgl 的工作流程
总共分为三个阶段，分别是初始化阶段，数据准备阶段，渲染管线阶段
初始化阶段：
在浏览器中，通过canvas获取webgl渲染上下文，编写并编译 顶点着色器程序 和 片段着色器程序，
然后连接成一个完成的程序

数据准备阶段：
准备好三维模型的顶点数据，包括相关的顶点属性，比如：顶点坐标，纹理坐标，法线等，然后将顶点数据存储到
GPU缓冲区中，最后要设置顶点属性，告诉gpu顶点数据的内存布局是什么

渲染管线阶段：
在这个阶段，顶点着色器会依次对每一个顶点做坐标变换，然后对顶点组装成三角形基本图元，然后在光栅化阶段把图元转换成像素片段
接着片元着色器会对每一个像素进行颜色计算和纹理采样，最后将像素写入缓冲区中显示

3.webgl中缓冲区是什么？是如何被使用的？
在webgl中是用于在GPU内存中存储顶点数据的对象，用于在CPU和GPU之间进行数据交换的桥梁
基于该对象可以使用gl.createBuffer() 在GPU中分配内存，使用gl.bindBuffer()激活
要操作的缓冲区，基于gl.bufferData()，可以实现cpu 到 gpu之间的数据传输
gl.vertexAttribPointer() 可用于告诉着色器如何读取数据
gl.enableVertexAttribArray() 可用于启动对应的顶点属性

4.什么是深度缓冲区，webgl是如何进行渲染的？
是GPU显存中专门用于存储每个像素深度值的内存区域，该深度值是每个片元在裁剪空间中的z分量，
其取值范围是[-1,1]
作用是：
1.解决三维场景中的遮挡物体前后的遮挡关系，确定物体之间前后的层次关系
2.用于深度测试，判断新渲染的像素是否应该覆盖已有的像素

5.什么是MVP矩阵，分别的作用是什么？
在说明什么是MVP矩阵之前，我们先要知道，无论是Cesuim 还是 threejs,都有最基本的四个坐标系：
分别是世界坐标系，局部坐标系，相机坐标系，裁剪坐标系，这几个坐标系之间的坐标值进行转换的过程中，需要借助MVP矩阵，
即：模型矩阵，视图矩阵，投影矩阵

模型矩阵：
作用是把顶点从局部坐标系转换到世界坐标系，定义了物体在三维世界中的位置和姿态，
并且可以实现对物体的平移，旋转，缩放

视图矩阵：
将顶点坐标从世界坐标变换到相机坐标系，定义了相机的位置，朝向和上方向
本质上是将整个世界相对于相机进行变换

投影矩阵：
将顶点从相机坐标系变换到裁剪坐标系，他定义了相机的整个视锥体
可以实现3D到2D的投影变换

变换的顺序是：(PVM)
局部坐标 -> 模型矩阵 -> 世界坐标 -> 视图矩阵 -> 相机坐标 -> 投影矩阵 -> 裁剪坐标

追加回答：上面使用MVP针对顶点的变换操作都是可以放到顶点着色器中执行，顶点着色器程序会借助GPU的并行能力，并行的处理每一个数据点

6.什么是正交投影和透视投影
这两种投影方式的作用是把三维场景投影到二维屏幕上。

正交投影进行的是平行投影，因为视锥体是长方体，所以他的投影线是平行于投影方向，
投影的物体是可以保持真实的比例和角度的

透视投影的所有投影线是从一个视点发出，其视锥体是一个截锥体，投影的物体具有近大远小的特点，符合人眼的视觉习惯
而且是能够很好的体现出3D空间的深度关系

7.什么是光照模型，常用的光照模型有哪些？
光照模型是一种用于模拟显示世界中光线与物体表面相互作用的数学模型，描述的是光源，物体表面材质 以及 观察者之间的关系
用于计算物体表面各个像素值的颜色和亮度。

有phong模型，Lambert光照模型，Blinn-Phong光照模型等

追加回答phong模型：
phong模型主要实现三种光照效果的组成：
1.环境光
模拟环境中的间接光照，为场景提供基础亮度
2.漫反射
光线在粗糙表面的均匀散射
3.镜面内反射
模拟光滑表面的高光效果，与观察角度相关

8.如何在webgl中使用Phong光照模型


9.法线的作用是什么？如何计算法线？
光照计算，计算光线与表面的夹角
背面剔除
- 通过法线方向判断三角形面片是正面还是背面
- 背面三角形可以被剔除以提高渲染性能
碰撞检测
- 法线用于判断物体表面的朝向
- 在物理模拟中计算反弹方向和碰撞响应
纹理映射
- 法线贴图技术使用法线信息增加表面细节
- 环境映射中用法线计算反射方向

已知由三个顶点构成三角形，基于这三个点计算出共端点的两个量，
最后对这两个向量 进行叉积运算 再归一化即可

10.什么是阴影映射？


11.什么是帧缓冲对象？
WebGL中用于实现离屏渲染的一个重要机制，他允许我们将渲染的结果输出到一个自定义的缓冲区中，
可以用于生成纹理、实现后处理特效、阴影贴图等高级效果
主要作用：
1. 离屏渲染：将渲染结果保存到纹理或缓冲区，而不是直接显示到屏幕上。
2. 多次渲染：可以多次对同一个缓冲区进行渲染，适合后处理、特效叠加等场景。
3. 阴影映射、反射、模糊等高级效果的实现。

12.	什么是齐次坐标？为什么 3D 变换要用 4×4 矩阵？
在计算机图形学中，齐次坐标是一种常用的表示方式，可以用于区分点和向量的表示方式，在三维空间中三维点的基础上增加了一个维度的点w,
如果w为0，这个齐次坐标表示的是方向向量，如果w不为0(或者为1)，表示的是一个点。

作用是：
1. 可以统一处理平移、旋转、缩放等所有仿射变换。
2. 方便矩阵运算，将所有变换都归结为矩阵乘法，便于在GPU中高效计算。
3. 支持投影变换（如透视投影），通过w分量实现坐标的归一化。

13.请解释 requestAnimationFrame 与 setInterval 在渲染循环中的差异

14.WebGL渲染性能优化有哪些方法？
1. **减少draw call数量**  
  合并多个物体到同一个缓冲区，使用批量渲染（Batch Rendering）技术，减少每帧调用`gl.drawArrays`或`gl.drawElements`的次数。
2. **减少状态切换**  
   尽量减少着色器、纹理、缓冲区等的频繁切换，合理排序渲染对象，批量处理同材质或同状态的物体。
3. **使用顶点缓存和索引缓存**  
   利用`gl.bufferData`和`gl.bufferSubData`将顶点数据一次性上传到GPU，避免每帧重复传输。
4. **使用合适的纹理格式和分辨率**  
   纹理不宜过大，压缩纹理格式（如ETC、S3TC等）可以减少显存占用和带宽消耗。

5. **LOD（细节层次）技术**  
   根据物体距离动态切换不同精度的模型，远处物体用低模，近处用高模，降低GPU负担。

6. **视锥体裁剪和遮挡剔除**  
   只渲染摄像机视野范围内的物体，避免无效渲染。

7. **合理使用帧缓冲对象（FBO）**  
   离屏渲染和后处理时，合理分配和复用FBO资源，避免频繁创建和销毁。

8. **减少CPU与GPU的数据交互**  
   尽量将计算和数据处理放在GPU端（着色器），减少JavaScript与WebGL API的频繁调用。

9. **优化着色器代码**  
   精简GLSL代码，避免复杂循环和分支，使用内置函数和向量运算提升效率。

10. **开启硬件加速和多线程**  
    利用Web Workers进行数据准备，开启浏览器硬件加速选项。

11. **使用实例化渲染（Instancing）**  
    对大量相同物体使用`ANGLE_instanced_arrays`扩展进行实例化渲染，减少draw call。

12. **延迟渲染（Deferred Rendering）**  
    对复杂场景采用延迟渲染技术，分离几何和光照计算，提升整体性能。


15.什么是批量渲染（Batch Rendering）？
批量渲染（Batch Rendering）是一种优化WebGL或OpenGL渲染性能的技术，通过将多个物体的顶点数据合并到同一个缓冲区，一次性提交给GPU进行渲染，从而减少draw call的数量。
批量渲染是提升WebGL渲染性能的常用方法之一，能够有效减少draw call数量，适用于需要同时渲染大量物体的场景

16.如何减少draw call的数量？
1. **批量渲染（Batch Rendering）**  
   将多个物体的顶点数据合并到同一个缓冲区，一次性提交给GPU进行渲染，减少多次调用`gl.drawArrays`或`gl.drawElements`。

2. **实例化渲染（Instancing）**  
   使用`ANGLE_instanced_arrays`扩展，对大量相同物体进行实例化渲染，只需一次draw call即可渲染多个实例。

3. **合并材质和着色器**  
   尽量让同一批渲染物体使用相同的材质和着色器，避免频繁切换状态，合并渲染流程。

4. **合并纹理（Texture Atlas）**  
   将多个小纹理合并到一张大纹理中，减少纹理切换次数，方便批量渲染。

5. **合理排序渲染对象**  
   按材质、着色器、纹理等状态进行分组排序，批量处理同状态的物体。

6. **减少动态创建和销毁缓冲区**  
   尽量复用缓冲区资源，避免每帧频繁创建和销毁，提升渲染效率。
17.LOD（细节层次）技术是什么？
LOD（Level of Detail，细节层次）技术是一种根据物体与摄像机距离动态切换不同精度模型的优化方法。它可以有效降低GPU和CPU的负担，提高渲染性能。

**主要原理**：
- 当物体距离摄像机较近时，使用高精度（高面数、高细节）的模型进行渲染；
- 当物体距离摄像机较远时，使用低精度（低面数、低细节）的模型进行渲染；
- 这样可以减少远处物体的顶点和面片数量，节省计算资源。

**应用场景**：
- 大型场景、地图、城市、角色等需要同时渲染大量物体的场合
- 游戏、虚拟现实、三维可视化等

**优点**：
- 显著提升渲染效率
- 降低显存和带宽消耗
- 保证近距离观察时的视觉质量

**实现方式**：
1. 为每个物体准备多套不同精度的模型（如高模、中模、低模）
2. 根据物体与摄像机的距离动态选择合适的模型进行渲染
3. 可以结合纹理LOD（mipmap）进一步优化

**总结**：
LOD技术是三维渲染中常用的性能优化手段之一，通过动态切换模型细节层次，实现高效且视觉质量良好的渲染效果。

18.请介绍webgl/opengl的渲染管线是怎么样的？

1.顶点处理阶段
顶点着色器程序对每一个顶点进行变换，以及法线、顶点属性的计算等
主要的作用是把顶点从模型空间变换到裁剪空间

2.图元装配阶段
将顶点组装成基本的图元，比如三角形，最终形成基本的线框模型

3.光栅化阶段
把每一个图元通过插值的方式，转换为屏幕上的像素片段，决定哪些像素会被绘制

4.片元处理阶段
片元着色器程序会对每个片元进行颜色计算，纹理采样，以及光照计算，生成最终颜色值

5.测试混合阶段
深度测试、模板测试、背面剔除操作

6.输出到帧缓冲区中
把最终的像素数据写入到帧缓冲区，显示在屏幕上

顶点数据 -> 片段着色器 -> 图元装配 -> 光栅化阶段 -> 片段着色器 -> 测试与混合 -> 帧缓冲区 -> 屏幕显示