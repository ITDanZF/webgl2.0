<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <script src="./js/WebGL.js"></script>
  <body>
    <script type="module">
      import WebGL from "./js/WebGL.js";
      const webgl = new WebGL("canvas");

      /**
       * 其次坐标系：利用齐次坐标，可以区分点和向量、更好地描述点和向量的变换操作。
       * 三维空间中的一个点坐标(x,y,z), 其次坐标形式是(x,y,z,w) w != 0,  w = 1时 前三项表示为一个位置坐标。
       * 当w = 0, 这时前三项表示为一个向量，即(x,y,z,0)。
       *
       * 通过其次坐标的方式可以更好的在矩阵变换操作的过程中进行描述
       * 1.平移操作：
       *    对于向量(x,y,z,0)，矩阵乘法的结果任然是(x,y,z,0)这个体现了向量只与相对位置有关。
       *    对于点(x,y,z,1)，矩阵乘法的结果是(x+dx,y+dy,z+dz,1)，这体现了点的位置会随着平移而改变。
       *
       * 2.缩放操作：
       *   对于向量(x,y,z,0)，矩阵乘法的结果是(kx,ky,kz,0)，这体现了向量的长度会随着缩放而改变。
       *   对于点(x,y,z,1)，矩阵乘法的结果是(kx,ky,kz,1)，这体现了点的位置会随着缩放而改变。
       *
       * 3.旋转操作：
       *    在旋转的过程中，w的值保持不变，点和向量的旋转效果是一样的。
       *
       */

      /**
       * 模型矩阵：
       *
       *
       *
       */
          // 创建立方体的着色器程序
      const programCube = webgl.useProgram(
        `#version 300 es

        layout(location = 0) in vec4 a_Position;
        void main() {
          gl_Position = a_Position;
        }
      `,
        `#version 300 es
        precision mediump float;
        out vec4 fragColor;
        void main() {
          fragColor = vec4(1.0, 0.0, 0.0, 1.0);
        }
        `
      );
      // 创建立方体缓冲区
      /**
       * 6 7
       * 4 5
       *
       * 3 2
       * 0 1
       *
       * */
      const vertexPosition = new Float32Array(
        [
          [-0.5, -0.5, 0.0], // 0
          [0.5, -0.5, 0.0], // 1
          [0.5, 0.5, 0.0], // 2
          [-0.5, 0.5, 0.0], // 3

          [-0.5, -0.5, 0.5], // 4
          [0.5, -0.5, 0.5], // 5
          [0.5, 0.5, 0.5], // 6
          [-0.5, 0.5, 0.5], // 7
        ].flat()
      );

      // 创建立方体缓冲区
      const cubeBufferId = webgl.gl.createBuffer();
      webgl.gl.bindBuffer(webgl.gl.ARRAY_BUFFER, cubeBufferId);
      webgl.gl.bufferData(
        webgl.gl.ARRAY_BUFFER,
        vertexPosition,
        webgl.gl.STATIC_DRAW
      );
      webgl.gl.vertexAttribPointer(0, 3, webgl.gl.FLOAT, false, 0, 0);
      webgl.gl.enableVertexAttribArray(0);

      // 创建索引缓冲区
      const IndexData = new Uint16Array(
        [
          [0, 1, 4, 1, 4, 5],
          [1, 5, 7, 1, 2, 7],
          [2, 3, 6, 2, 3, 7],
          [0, 3, 4, 3, 4, 6],
          [4, 5, 6, 5, 6, 7],
          [0, 3, 1, 1, 2, 3],
        ].flat()
      );

      // 创建索引缓冲区
      const IndexBufferId = webgl.gl.createBuffer();
      webgl.gl.bindBuffer(webgl.gl.ELEMENT_ARRAY_BUFFER, IndexBufferId);
      webgl.gl.bufferData(
        webgl.gl.ELEMENT_ARRAY_BUFFER,
        IndexData,
        webgl.gl.STATIC_DRAW
      );

      // 清屏颜色
      webgl.gl.clearColor(0, 0, 0, 0);
      webgl.gl.clear(webgl.gl.COLOR_BUFFER_BIT);

      // 绘制
      webgl.gl.drawElements(
              webgl.gl.TRIANGLES,
              IndexData.length,
              webgl.gl.UNSIGNED_SHORT,
              0
      );

      //
    </script>
  </body>
</html>
