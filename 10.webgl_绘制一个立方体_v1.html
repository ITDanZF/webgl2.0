<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <script src="./js/WebGL.js"></script>
  <body>
    <script type="module">
      import WebGL from "./js/WebGL.js";
      const webgl = new WebGL("canvas");

      /**
       * 当模视矩阵为单位矩阵，即不进行模视矩阵变换，此时：
       * 1.世界坐标系和相机坐标系时完全重合的
       * 2.相机位于原点
       * 3.相机的视线时 Z负半轴方向
       *  只有做了模视矩阵变换，才能把相机坐标系和世界坐标系分开
       *
       */

      /**
       * 在 99% 的实时渲染管线（包括 WebGL/Three.js）里，“相机坐标系”是固定不变的：
       * 相机坐标系永远保持
       * – 原点 (0,0,0) 就是相机本身
       * – +X 向右，+Y 向上，-Z 指向视线方向
       * 世界坐标系里的物体则通过视图矩阵 V 被整体“搬”到这个固定相机系里。
       * 换句话说：
       * 世界坐标系里的所有顶点先被 V 变换，再进入裁剪空间；相机系本身不动。
       * 因此，当我们“移动相机”时，其实只是在 CPU 端重新计算一个新的视图矩阵（把世界整体反方向搬到相机原点），而相机坐标系的定义始终不变。
       *
       */

      /**
       * 其次坐标系：利用齐次坐标，可以区分点和向量、更好地描述点和向量的变换操作。
       * 三维空间中的一个点坐标(x,y,z), 其次坐标形式是(x,y,z,w) w != 0,  w = 1时 前三项表示为一个位置坐标。
       * 当w = 0, 这时前三项表示为一个向量，即(x,y,z,0)。
       *
       * 通过其次坐标的方式可以更好的在矩阵变换操作的过程中进行描述
       * 1.平移操作：
       *    对于向量(x,y,z,0)，矩阵乘法的结果任然是(x,y,z,0)这个体现了向量只与相对位置有关。
       *    对于点(x,y,z,1)，矩阵乘法的结果是(x+dx,y+dy,z+dz,1)，这体现了点的位置会随着平移而改变。
       *
       * 2.缩放操作：
       *   对于向量(x,y,z,0)，矩阵乘法的结果是(kx,ky,kz,0)，这体现了向量的长度会随着缩放而改变。
       *   对于点(x,y,z,1)，矩阵乘法的结果是(kx,ky,kz,1)，这体现了点的位置会随着缩放而改变。
       *
       * 3.旋转操作：
       *    在旋转的过程中，w的值保持不变，点和向量的旋转效果是一样的。
       *
       */

      /**
       * MVP矩阵：
       * 模型矩阵(Model)：
       * 模型矩阵本质上是一个从“模型坐标系”到“世界坐标系”的变换矩阵，表示把模型坐标系如何通过 旋转 缩放 平移的方式嵌入到世界坐标系的规则。
       * 模型矩阵的推导，就是要把该向量在模型坐标系中的线性组合，用世界坐标系的基底来重写(即变换)。
       *    变换前：模型坐标空间   变换后：世界坐标空间
       *    平移变换矩阵：T   旋转变换矩阵：R   缩放变换矩阵：S   模型坐标系下的齐次坐标：V   世界坐标系下的齐次坐标：V'
       *    模型矩阵：M = T * R * S
       *    V' = M * V
       *       = T * R * S * V
       *
       * 视图矩阵(View)：
       * 变换前：世界坐标空间   变换后：相机坐标空间
       * 变换目的：计算物体对相机的相对位置，以便进行后续变换。
       * 相机坐标空间的向量：Pv  世界坐标系中的向量：Pm   相机的旋转矩阵：Rview   相机的平移矩阵：Tview
       *  视图矩阵：V = Rview * Tview
       *  Pv = V * Pm
       *     = Rview * Tview * Pm
       *
       *  投影矩阵(Projection)：透视投影
       *  变换前：相机坐标空间   变换后：标准视体空间（裁剪空间）
       *  投影矩阵：Mproj
       *  投影变换：
       *    Pp = Mproj * Pv
       *
       *  最终的变换矩阵(MVP)：
       *  模型矩阵： Model  视图矩阵： View  投影矩阵： Projection
       *  MVP = Model * View * Projection
       *
       *  MVP矩阵变换过程：
       *
       *  三维空间中的任意一点(齐次坐标)：P = (x, y, z, 1)
       *  裁剪空间坐标：Pclip = (x', y', z', w')
       *
       *  Pclip = MVP * P
       *  NDC空间坐标：Pndc = Pclip / w'
       *
       *  总结：经过MVP矩阵变换后，可以将三维物体正确的渲染在二维屏幕上
       */

      // 生成MVP矩阵：


              // 弧度函数
      const rad = d => d * Math.PI / 180;


      // 矩阵乘法
      function mul(a, b) {
        const out = new Float32Array(16);
        const a00=a[0],  a01=a[1],  a02=a[2],  a03=a[3];
        const a10=a[4],  a11=a[5],  a12=a[6],  a13=a[7];
        const a20=a[8],  a21=a[9],  a22=a[10], a23=a[11];
        const a30=a[12], a31=a[13], a32=a[14], a33=a[15];

        let b0=b[0], b1=b[1], b2=b[2], b3=b[3];
        out[0] = a00*b0 + a10*b1 + a20*b2 + a30*b3;
        out[1] = a01*b0 + a11*b1 + a21*b2 + a31*b3;
        out[2] = a02*b0 + a12*b1 + a22*b2 + a32*b3;
        out[3] = a03*b0 + a13*b1 + a23*b2 + a33*b3;

        b0=b[4]; b1=b[5]; b2=b[6]; b3=b[7];
        out[4] = a00*b0 + a10*b1 + a20*b2 + a30*b3;
        out[5] = a01*b0 + a11*b1 + a21*b2 + a31*b3;
        out[6] = a02*b0 + a12*b1 + a22*b2 + a32*b3;
        out[7] = a03*b0 + a13*b1 + a23*b2 + a33*b3;

        b0=b[8]; b1=b[9]; b2=b[10]; b3=b[11];
        out[8]  = a00*b0 + a10*b1 + a20*b2 + a30*b3;
        out[9]  = a01*b0 + a11*b1 + a21*b2 + a31*b3;
        out[10] = a02*b0 + a12*b1 + a22*b2 + a32*b3;
        out[11] = a03*b0 + a13*b1 + a23*b2 + a33*b3;

        b0=b[12]; b1=b[13]; b2=b[14]; b3=b[15];
        out[12] = a00*b0 + a10*b1 + a20*b2 + a30*b3;
        out[13] = a01*b0 + a11*b1 + a21*b2 + a31*b3;
        out[14] = a02*b0 + a12*b1 + a22*b2 + a32*b3;
        out[15] = a03*b0 + a13*b1 + a23*b2 + a33*b3;

        return out;
      }

      // 模型矩阵
      function mat4ModelTRS(t=[0,0,0], r=[0,0,0], s=[1,1,1]) {
        // 平移矩阵
        function T(tx, ty, tz) {
          const m = new Float32Array(16);
          m[0] = 1; m[5] = 1; m[10] = 1; m[15] = 1;
          m[12] = tx; m[13] = ty; m[14] = tz;
          return m;
        }

        // 旋转矩阵
        function Rx(theta) {
          const c = Math.cos(theta), s = Math.sin(theta);
          const m = new Float32Array(16);
          m[0] = 1; m[15] = 1;
          m[5] = c; m[6] = s; m[9] = -s; m[10] = c;
          return m;
        }
        function Ry(theta) {
          const c = Math.cos(theta), s = Math.sin(theta);
          const m = new Float32Array(16);
          m[5] = 1; m[15] = 1;
          m[0] = c; m[8] = s; m[2] = -s; m[10] = c;
          return m;
        }
        function Rz(theta) {
          const c = Math.cos(theta), s = Math.sin(theta);
          const m = new Float32Array(16);
          m[10] = 1; m[15] = 1;
          m[0] = c; m[1] = s; m[4] = -s; m[5] = c;
          return m;
        }

        // 缩放矩阵
        function S(sx, sy, sz) {
          const m = new Float32Array(16);
          m[0] = sx; m[5] = sy; m[10] = sz; m[15] = 1;
          return m;
        }
        const TM  = T(t[0], t[1], t[2]);
        const RxM = Rx(r[0]);
        const RyM = Ry(r[1]);
        const RzM = Rz(r[2]);
        const SM  = S(s[0], s[1], s[2]);

        // M = T * Rz * Ry * Rx * S（分步硬编码乘法，避免嵌套）
        const RS    = mul(RxM, SM);
        const RYS   = mul(RyM, RS);
        const RZYS  = mul(RzM, RYS);
        const Model = mul(TM, RZYS);
        return Model;
      }

      // 透视投影矩阵（fovy 弧度，near>0，far>near）
      function mat4Perspective(fovy, aspect, near, far) {
        const f = 1 / Math.tan(fovy / 2);
        const nf = 1 / (near - far);
        const m = new Float32Array(16);
        m[0] = f / aspect;
        m[5] = f;
        m[10] = (far + near) * nf;
        m[11] = -1;
        m[14] = 2 * far * near * nf;
        return m;
      }

      // 视图矩阵（eye 相机位置，center 相机看向的点，up 相机的上方向）
      function mat4ViewLookAt(eye = [0,0,3], center = [0,0,0], up = [0,1,0]) {
        const [ex, ey, ez] = eye;
        const [cx, cy, cz] = center;
        const [ux, uy, uz] = up;

        // z 轴：相机前向的反方向（右手系）
        let zx = ex - cx, zy = ey - cy, zz = ez - cz;
        let len = Math.hypot(zx, zy, zz);
        zx /= len; zy /= len; zz /= len;

        // x 轴：right = normalize(cross(up, z))
        let xx = uy * zz - uz * zy;
        let xy = uz * zx - ux * zz;
        let xz = ux * zy - uy * zx;
        len = Math.hypot(xx, xy, xz);
        xx /= len; xy /= len; xz /= len;

        // y 轴：up' = cross(z, x)
        const yx = zy * xz - zz * xy;
        const yy = zz * xx - zx * xz;
        const yz = zx * xy - zy * xx;

        // 列主序填充
        const out = new Float32Array(16);
        // 第1列：right
        out[0] = xx; out[1] = yx; out[2] = zx; out[3] = 0;
        // 第2列：up'
        out[4] = xy; out[5] = yy; out[6] = zy; out[7] = 0;
        // 第3列：forward(相机看向的反方向)
        out[8]  = xz; out[9]  = yz; out[10] = zz; out[11] = 0;
        // 第4列：平移
        out[12] = -(xx * ex + xy * ey + xz * ez);
        out[13] = -(yx * ex + yy * ey + yz * ez);
        out[14] = -(zx * ex + zy * ey + zz * ez);
        out[15] = 1;
        return out;
      }


      // MVP矩阵
      function MVP(t, r, s, eye, center, up, fovy, aspect, near, far) {
        const M = mat4ModelTRS(t, r, s);
        const V = mat4ViewLookAt(eye, center, up);
        const P = mat4Perspective(fovy, aspect, near, far);
        return mul(mul(P, V), M);
      }


      // 立方体的参数
      const position = [0, 0, 0];// 立方体在世界坐标系的位置
      const rotation = [rad(50), rad(0), rad(0)]; // 立方体的旋转角度
      const scale = [1, 1, 1]; // 立方体的缩放比例

      // 相机参数
      const eye = [0, 0, 5]; // 相机位置
      const center = [0, 0, 0]; // 相机看向的点
      const up = [0, 1, 0]; // 相机的上方向
      const fovy = rad(45); // 视野角度
      const aspect = webgl.gl.canvas.width / webgl.gl.canvas.height; // 视口宽高比
      const near = 0.1; // 近裁剪面
      const far = 100; // 远裁剪面

      const mvp = MVP(
        position,
        rotation,
        scale,
        eye,
        center,
        up,
        fovy,
        aspect,
        near,
        far
      );

      // 创建立方体的着色器程序
      const programCube = webgl.useProgram(
        `#version 300 es
        uniform mat4 u_MVP;
        layout(location = 0) in vec4 a_Position;
        void main() {
          gl_Position = u_MVP * a_Position;
        }
      `,
        `#version 300 es
        precision mediump float;
        out vec4 fragColor;
        void main() {
          fragColor = vec4(1.0, 0.0, 0.0, 1.0);
        }
        `
      );
      // 创建立方体缓冲区
      /**
       * 7 6
       * 4 5
       *
       * 3 2
       * 0 1
       *
       * */
      const vertexPosition = new Float32Array(
        [
          [-0.5, -0.5,-0.5 ], // 0
          [0.5, -0.5, -0.5 ], // 1
          [0.5, 0.5,  -0.5 ], // 2
          [-0.5, 0.5, -0.5 ], // 3

          [-0.5, -0.5, 0.5], // 4
          [0.5, -0.5, 0.5], // 5
          [0.5, 0.5, 0.5], // 6
          [-0.5, 0.5, 0.5], // 7
        ].flat()
      );

      // 创建立方体缓冲区
      const cubeBufferId = webgl.gl.createBuffer();
      webgl.gl.bindBuffer(webgl.gl.ARRAY_BUFFER, cubeBufferId);
      webgl.gl.bufferData(
        webgl.gl.ARRAY_BUFFER,
        vertexPosition,
        webgl.gl.STATIC_DRAW
      );
      webgl.gl.vertexAttribPointer(0, 3, webgl.gl.FLOAT, false, 0, 0);
      webgl.gl.enableVertexAttribArray(0);

      // 创建索引缓冲区
      const IndexData = new Uint16Array(
        [
          [0, 1, 4,   4, 1, 5],
          [1, 5, 6,   6, 2, 1],
          [2, 3, 7,   7, 6, 2],
          [0, 3, 7,   7, 4, 0],
          [4, 5, 6,   6, 7, 5],
          [0, 1, 2,   2, 3, 0],
        ].flat()
      );

      // 创建索引缓冲区
      const IndexBufferId = webgl.gl.createBuffer();
      webgl.gl.bindBuffer(webgl.gl.ELEMENT_ARRAY_BUFFER, IndexBufferId);
      webgl.gl.bufferData(
        webgl.gl.ELEMENT_ARRAY_BUFFER,
        IndexData,
        webgl.gl.STATIC_DRAW
      );

      webgl.setUniformMatrix4(programCube, "u_MVP", mvp);

      // 清屏颜色
      webgl.gl.clearColor(0, 0, 0, 0);
      webgl.gl.enable(webgl.gl.DEPTH_TEST);
      webgl.gl.clear(webgl.gl.COLOR_BUFFER_BIT);

      // 绘制
      webgl.gl.drawElements(
              webgl.gl.TRIANGLES,
              IndexData.length,
              webgl.gl.UNSIGNED_SHORT,
              0
      );

      //
    </script>
  </body>
</html>
