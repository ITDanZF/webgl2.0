<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
    </head>
    <body>
        <script src="./js/Math.js"></script>
        <script src="./js/Render.js"></script>
        <script src="./js/WebGL.js"></script>
        <script type="module">
            import WebGL from './js/WebGL.js';

            const webgl = new WebGL('webgl-canvas');

            // 创建着色器程序
            // 着色器中的 layout(location = X) 中的 X 值必须与 vertexAttribPointer 和 enableVertexAttribArray 的第一个参数（属性索引）保持一致
            const vertex = `#version 300 es

      layout(location = 0) in vec4 a_Position;
      layout(location = 1) in vec2 a_UV;

      out vec2 v_UV; // 将UV坐标传递给片元着色器
      void main () {
        v_UV = a_UV; // 将UV坐标传递给片元着色器
        gl_Position = a_Position;
      }`;

            const fragment = `#version 300 es
      precision mediump float;

      in vec2 v_UV; // 接收顶点着色器传递的UV坐标
      out vec4 fragColor;
      void main () {
        fragColor = vec4(v_UV.x, v_UV.y, 1.0, 0.6);
      }
      `;
            const program = webgl.useProgram(vertex, fragment);

            // 创建并绑定顶点缓冲区
            const positionBuffer = webgl.Bind(webgl.gl.ARRAY_BUFFER);

            // 创建数据并把数据输入顶点缓冲区中 (包含UV坐标)
            const positionData = new Float32Array([
                -0.5,
                -0.5,
                0.0,
                0.0,
                0.0, // 0
                0.5,
                -0.5,
                0.0,
                1.0,
                0.0, // 1
                0.5,
                0.5,
                0.0,
                1.0,
                1.0, // 2
                -0.5,
                0.5,
                0.0,
                0.0,
                1.0, //3
            ]);
            webgl.gl.bufferData(
                webgl.gl.ARRAY_BUFFER,
                positionData,
                webgl.gl.STATIC_DRAW
            );

            // 创建索引缓冲区
            const indexBuffer = webgl.Bind(webgl.gl.ELEMENT_ARRAY_BUFFER);
            const indexData = new Uint16Array([0, 1, 2, 0, 2, 3]);
            webgl.gl.bufferData(
                webgl.gl.ELEMENT_ARRAY_BUFFER,
                indexData,
                webgl.gl.STATIC_DRAW
            );
            // 这里第五个参数stride为0表示数据紧密排列，WebGL会自动计算步长。
            // webgl.gl.vertexAttribPointer(0, 3, webgl.gl.FLOAT, false, 0, 0);

            // 重新定义顶点中 坐标属性的内存布局：3个分量，数据类型是float, 两个顶点的坐标属性之间相隔5 * 4 字节，坐标属性在顶点内的第0个起始字节开始
            webgl.gl.vertexAttribPointer(
                0,
                3,
                webgl.gl.FLOAT,
                false,
                5 * Float32Array.BYTES_PER_ELEMENT,
                0
            );
            webgl.gl.enableVertexAttribArray(0); // 表示激活 顶点属性中 第0个属性

            // 重新定义顶点中 UV属性的内存布局：2个分量，数据类型是float, 两个顶点的UV属性之间相隔5 * 4 字节，UV属性在顶点内的第3个起始字节开始
            webgl.gl.vertexAttribPointer(
                1,
                2,
                webgl.gl.FLOAT,
                false,
                5 * Float32Array.BYTES_PER_ELEMENT,
                3 * Float32Array.BYTES_PER_ELEMENT
            );
            webgl.gl.enableVertexAttribArray(1); // 表示激活 顶点属性中 第1个属性

            // 清屏颜色
            webgl.gl.clearColor(0, 0, 0, 0);
            webgl.gl.clear(webgl.gl.COLOR_BUFFER_BIT);
            // 启用混合功能
            webgl.gl.enable(webgl.gl.BLEND);
            // 设置混合函数
            webgl.gl.blendFunc(
                webgl.gl.SRC_ALPHA,
                webgl.gl.ONE_MINUS_SRC_ALPHA
            );
            webgl.gl.drawElements(
                webgl.gl.TRIANGLES,
                indexData.length,
                webgl.gl.UNSIGNED_SHORT,
                0
            );
        </script>
    </body>
</html>
