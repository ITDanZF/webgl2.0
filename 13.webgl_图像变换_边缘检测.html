<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
    </head>
    <body>
        <script type="module">
            import WebGL from './js/WebGL.js';
            import { MorthoMatrix } from './js/Math.js';

            const webgl = new WebGL('canvas');

            webgl.setCanvasBackGroundColor('black');
            webgl.setBodyBackgroundColor('black');

            /**
       * texture 函数：
       * 用于从 GPU 内存中的纹理数据中提取颜色值，texture提取的对象本质上是多维纹理数组的颜色值
       * 在本案例中，由于是2D图像纹理，提取的自然是二维纹理数组的颜色值
       *
       * 纹理坐标：
       * texture 函数在提取颜色值时，使用的是纹理坐标，取值范围是[0.0,1.0]
       *
       * 案例：
       * onePixel = (1/width, 1/height)
       * 把一个像素(texel)的位移换算成UV位移步长,如果沿U方向移动1像素需要加上 1/width, 沿V方向移动1像素要加上1/height
       * v_TexCoord：传入了纹理坐标索引后，在片段着色器中，v_TexCoord 是每个像素的纹理坐标
       *
       * v_TexCoord + onePixel * vec2(dx, dy))  ,dx 在[-1,1]，dy 在[-1,1]区间
       * 该公式表示：
       * 在当前像素的纹理坐标基础上，沿U方向移动dx个像素，沿V方向移动dy个像素，而卷积核的计算就是计算九宫格的像素值乘积和
       * 
       * 九宫格偏移对照（以你的代码顺序）：
       *
       *  vec2(-1, -1): 左下
       *  vec2( 0, -1): 中下
       *  vec2( 1, -1): 右下
       *  vec2(-1, 0): 左中
       *  vec2( 0, 0): 中心（当前像素）
       *  vec2( 1, 0): 右中
       *  vec2(-1, 1): 左上
       *  vec2( 0, 1): 中上
          vec2( 1, 1): 右上
       * 
       * */

            const program = webgl.useProgram(
                `#version 300 es
                        layout(location = 0) in vec4 a_Position;
                        layout(location = 1) in vec2 a_TexCoord;
                        uniform mat4 u_Ortho;
                        out vec2 v_TexCoord;
                        void main () {
                            gl_Position = u_Ortho * a_Position;
                            v_TexCoord = a_TexCoord;
                        }
                    `,
                `#version 300 es
                        precision mediump float;
                        in vec2 v_TexCoord;
                        out vec4 fragColor;
                        uniform sampler2D u_Sampler;
                        uniform vec2 u_TexSize; // 新增：纹理大小

                        void main () {
                            vec2 onePixel = vec2(1.0, 1.0) / u_TexSize;

                            // 简单的边缘检测内核
                            mat3 kernel = mat3(
                                -1.0, -1.0, -1.0,
                                -1.0,  8.0, -1.0,
                                -1.0, -1.0, -1.0
                            );

                            vec4 colorSum = 
                                texture(u_Sampler, v_TexCoord + onePixel * vec2(-1, -1)) * kernel[0][0] +
                                texture(u_Sampler, v_TexCoord + onePixel * vec2( 0, -1)) * kernel[0][1] +
                                texture(u_Sampler, v_TexCoord + onePixel * vec2( 1, -1)) * kernel[0][2] +
                                texture(u_Sampler, v_TexCoord + onePixel * vec2(-1,  0)) * kernel[1][0] +
                                texture(u_Sampler, v_TexCoord + onePixel * vec2( 0,  0)) * kernel[1][1] +
                                texture(u_Sampler, v_TexCoord + onePixel * vec2( 1,  0)) * kernel[1][2] +
                                texture(u_Sampler, v_TexCoord + onePixel * vec2(-1,  1)) * kernel[2][0] +
                                texture(u_Sampler, v_TexCoord + onePixel * vec2( 0,  1)) * kernel[2][1] +
                                texture(u_Sampler, v_TexCoord + onePixel * vec2( 1,  1)) * kernel[2][2];

                            fragColor = vec4(colorSum.rgb, 1.0);
                        }
                    `
            );

            // 加载图形图像
            const image = new Image();
            image.src = './images/cuteGirl.png';
            image.onload = function () {
                // 按窗口可用空间等比缩小 canvas
                const scale = Math.min(
                    window.innerWidth / image.width,
                    window.innerHeight / image.height,
                    1
                );
                const canvasW = Math.round(image.width * scale);
                const canvasH = Math.round(image.height * scale);
                webgl.setCanvasSize(canvasW, canvasH);

                const W = webgl.gl.drawingBufferWidth;
                const H = webgl.gl.drawingBufferHeight;
                webgl.gl.viewport(0, 0, W, H);
                const Mortho = MorthoMatrix(0, W, 0, H, -1, 1);
                const uOrtho = webgl.gl.getUniformLocation(program, 'u_Ortho');
                webgl.gl.uniformMatrix4fv(uOrtho, false, Mortho);

                const x0 = 0.0;
                const y0 = 0.0;
                const w = W;
                const h = H;
                webgl.VertexBufferData(
                    webgl.gl.ARRAY_BUFFER,
                    new Float32Array(
                        [
                            [x0, y0, 0.0],
                            [x0 + w, y0, 0.0],
                            [x0 + w, y0 + h, 0.0],
                            [x0, y0 + h, 0.0],
                        ].flat()
                    ),
                    webgl.gl.STATIC_DRAW,
                    [{ location: 0, size: 3 }]
                );
                webgl.VertexBufferData(
                    webgl.gl.ARRAY_BUFFER,
                    new Float32Array(
                        [
                            [0.0, 1.0], // 左下角 (0, 1) —— Y=1 是底部，对应图像顶部
                            [1.0, 1.0], // 右下角 (1, 1)
                            [1.0, 0.0], // 右上角 (1, 0) —— Y=0 是顶部，对应图像底部
                            [0.0, 0.0], // 左上角 (0, 0)
                        ].flat()
                    ),
                    webgl.gl.STATIC_DRAW,
                    [{ location: 1, size: 2 }]
                );
                webgl.IndexBufferData(
                    webgl.gl.ELEMENT_ARRAY_BUFFER,
                    new Uint16Array([0, 1, 2, 0, 2, 3]),
                    webgl.gl.STATIC_DRAW
                );

                const texture = webgl.gl.createTexture();
                webgl.gl.bindTexture(webgl.gl.TEXTURE_2D, texture);
                webgl.gl.texParameteri(
                    webgl.gl.TEXTURE_2D,
                    webgl.gl.TEXTURE_WRAP_S,
                    webgl.gl.CLAMP_TO_EDGE
                );
                webgl.gl.texParameteri(
                    webgl.gl.TEXTURE_2D,
                    webgl.gl.TEXTURE_WRAP_T,
                    webgl.gl.CLAMP_TO_EDGE
                );
                webgl.gl.texParameteri(
                    webgl.gl.TEXTURE_2D,
                    webgl.gl.TEXTURE_MIN_FILTER,
                    webgl.gl.LINEAR
                );
                webgl.gl.texParameteri(
                    webgl.gl.TEXTURE_2D,
                    webgl.gl.TEXTURE_MAG_FILTER,
                    webgl.gl.LINEAR
                );

                // 4.将图像数据上传到纹理对象
                webgl.gl.texImage2D(
                    webgl.gl.TEXTURE_2D,
                    0,
                    webgl.gl.RGBA,
                    webgl.gl.RGBA,
                    webgl.gl.UNSIGNED_BYTE,
                    image
                );

                webgl.gl.activeTexture(webgl.gl.TEXTURE0);
                webgl.gl.bindTexture(webgl.gl.TEXTURE_2D, texture);
                const samplerLocation = webgl.gl.getUniformLocation(
                    program,
                    'u_Sampler'
                );
                webgl.gl.uniform1i(samplerLocation, 0);

                const uTexSize = webgl.gl.getUniformLocation(
                    program,
                    'u_TexSize'
                );
                webgl.gl.uniform2f(uTexSize, image.width, image.height);

                webgl.gl.drawArrays(webgl.gl.TRIANGLE_FAN, 0, 4);
            };
        </script>
    </body>
</html>
